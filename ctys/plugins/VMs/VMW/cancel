#!/bin/bash
########################################################################
#
#PROJECT:      Unified Sessions Manager
#AUTHOR:       Arno-Can Uestuensoez - acue@UnifiedSessionsManager.org
#MAINTAINER:   Arno-Can Uestuensoez - acue_sf1@sourceforge.net
#SHORT:        ctys
#CALLFULLNAME: Commutate To Your Session
#LICENCE:      GPL3
#VERSION:      01_02_007a17
#
########################################################################
#
# Copyright (C) 2007 Arno-Can Uestuensoez (UnifiedSessionsManager.org)
#
########################################################################

_myPKGNAME_VMW_CANCEL="${BASH_SOURCE}"
_myPKGVERS_VMW_CANCEL="01.02.001b01"
hookInfoAdd $_myPKGNAME_VMW_CANCEL $_myPKGVERS_VMW_CANCEL




#FUNCBEG###############################################################
#NAME:
#  cutCancelSessionVMW
#
#TYPE:
#  bash-function
#
#DESCRIPTION:
#
#EXAMPLE:
#
#PARAMETERS:
#
#
#OUTPUT:
#  RETURN:
#
#  VALUES:
#
#FUNCEND###############################################################
function cutCancelSessionVMW () {
  local OPMODE=$1;shift
  local ACTION=$1;shift

  #Killing server alone is senseless, so client else both is applicable.
  local _CSB=BOTH;

  local _behaviour=;
  local _i=;

  case ${OPMODE} in
      CHECKPARAM)
          #
          #Just check syntax drafts, the expansion of labels etc. could just be
          #expanded on target machine.
          #

          if [ -n "$CTRL_MODE_ARGS" ];then
              A=`echo ${CTRL_MODE_ARGS}|sed 's/,/ /g'`
              printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "WMW($A)"

              #guarantee unambiguity
              local _unambig=0;
              local _unambigCSB=0;
              local _unambigCMD=0;
              for i in $A;do
		  KEY=`echo ${i}|awk -F':' '{print $1}'|tr '[:lower:]' '[:upper:]'`
		  ARG=`echo ${i}|awk -F':' '{print $2}'`

		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "KEY=${KEY}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "ARG=<${ARG}>"
                  #handle keywords
                  if [ -n "${ARG}" \
		      -o -z "${ARG}" -a "${KEY}" == "CLIENT" \
		      -o -z "${ARG}" -a "${KEY}" == "SERVER" \
		      -o -z "${ARG}" -a "${KEY}" == "BOTH" \
                      -o -z "${ARG}" -a "${KEY}" == "S3" \
                      -o -z "${ARG}" -a "${KEY}" == "S4" \
		      -o -z "${ARG}" -a "${KEY}" == "S5" \
                      -o -z "${ARG}" -a "${KEY}" == "REBOOT" \
                      -o -z "${ARG}" -a "${KEY}" == "RESET" \
                      -o -z "${ARG}" -a "${KEY}" == "PAUSE" \
                      -o -z "${ARG}" -a "${KEY}" == "SUSPEND" \
                      -o -z "${ARG}" -a "${KEY}" == "POWEROFF" \
		      -o -z "${ARG}" -a "${KEY}" == "FORCE" \
		      -o -z "${ARG}" -a "${KEY}" == "STACK" \
		      -o -z "${ARG}" -a "${KEY}" == "SELF" \
		      -o -z "${ARG}" -a "${KEY}" == "ALL" \
		      -o -z "${ARG}" -a "${KEY}" == "NOCACHE" \
		      -o -z "${ARG}" -a "${KEY}" == "NOPOLL" \
                      ];then
		      case $KEY in

                     ##################################################
                     # Common control enforcement scope and behaviour #
                     ##################################################
			  FORCE)
                              local _force=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:FORCE"
			      ;;

			  STACK)
                              local _stack=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:STACK (DEFAULT)"
			      ;;

			  SELF)
                              local _self=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:SELF"
			      ;;

                     ##################
                     # Common methods #  
                     ##################
			  REBOOT)
                              local _reboot=1;
			      let _unambigCMD+=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:REBOOT"
			      ;;
			  RESET)
                              local _reset=1;
			      let _unambigCMD+=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:RESET"
			      ;;
			  PAUSE|S3)
                              local _pause=1;
			      let _unambigCMD+=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:PAUSE-S3"
			      ;;
			  SUSPEND|S4)
                              local _suspend=1;
			      let _unambigCMD+=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:SUSPEND-S4"
			      ;;
			  POWEROFF|S5)
                              local _powoff=1;
                              local _powoffdelay="${ARG}";
			      let _unambigCMD+=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:POWEROFF-S5 DELAY=${_powoffdelay}"
			      ;;

			  INIT)
                              local _init=1;
                              local _initstate="${ARG}";
			      let _unambigCMD+=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:INIT STATE=${_initstate}"
			      ;;


                     #####################
                     # <machine-address> #
                     #####################
			  NOCACHE)
			      local _cache=0;
			      printWNG $LINENO $BASH_SOURCE 0 "NOCACHE not yet implemented"
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "NOCACHE"
			      ;;
			  NOPOLL)
			      local _poll=0;
			      printWNG $LINENO $BASH_SOURCE 0 "NOPOLL not yet implemented"
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "NOPOLL"
			      ;;


			  BASEPATH|BASE|B)
                              local _base="${ARG}";
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:BASE=${_base}"
			      ;;
			  TCP|T)
			      local _tcp="${ARG}";
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "TCP=${_tcp}"
			      let _unambig+=1;
			      ;;
			  MAC|M)
			      local _mac="${ARG}";
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MAC=${_mac}"
			      let _unambig+=1;
			      ;;
			  UUID|U)
                              local _uuid="${ARG}";
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:UUID=${_uuid}"
			      let _unambig+=1;
			      ;;
			  LABEL|L)
                              local _label="${ARG}";
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:LABEL=${_label}"
			      let _unambig+=1;
			      ;;
			  FILENAME|FNAME|F)
                              local _fname="${ARG}";
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:FILENAME=${_fname}"
			      let _unambig++;
			      ;;
			  ID|I|PATHNAME|PNAME|P)
                              #can (partly for relative names) be checked now
                              if [ -n "${ARG##/*}" ]; then
				  ABORT=1;
				  printERR $LINENO $BASH_SOURCE ${ABORT} "PNAME has to be an absolute path, use fname else."
				  printERR $LINENO $BASH_SOURCE ${ABORT} "  PNAME=${ARG}"
 				  gotoHell ${ABORT}
                              fi
			      let _unambig++;
                              local _idgiven=1;
			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:PATHNAME=${ARG}"
			      ;;


                     #######################
                     # Specific attributes #  
                     #######################
			  ALL)
                              local _all=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:ALL"
			      let _unambig+=1;
			      ;;


			  CLIENT)
			      _CSB=CLIENT;
			      let _unambigCSB+=1;
 			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:CLIENT"
			      ;;
			  SERVER)
			      _CSB=SERVER;
			      let _unambigCSB+=1;
  			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:SERVER"
			      ;;
			  BOTH)
			      _CSB=BOTH;
			      let _unambigCSB+=1;
  			      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:BOTH=CLIENT+SERVER"
			      ;;



			  *)
			      ABORT=1;
			      printERR $LINENO $BASH_SOURCE ${ABORT} "Unknown sub-opts for VMW:${KEY}"
 			      gotoHell ${ABORT}
			      ;;
		      esac
                  else
		      ABORT=1;
		      printERR $LINENO $BASH_SOURCE ${ABORT} "Erroneous KEY:<${KEY}>"
 		      printERR $LINENO $BASH_SOURCE ${ABORT} "  Required syntax :<KEY>:<ARG>";
 		      printERR $LINENO $BASH_SOURCE ${ABORT} "  Given systax    :<${KEY}>:<${ARG}>";
 		      gotoHell ${ABORT}               
		  fi
	      done

              #0. validate ambiguity of address
              if((_unambig>1));then
		  ABORT=1;
		  printERR $LINENO $BASH_SOURCE ${ABORT} "The following sub-opts are EXOR applicable only:"
		  printERR $LINENO $BASH_SOURCE ${ABORT} "  label|tcp|mac|uuid|fname|pname|all"
 		  gotoHell ${ABORT}
              fi

              #1. validate ambiguity of CBS
              if((_unambigCSB>1));then
		  ABORT=1;
		  printERR $LINENO $BASH_SOURCE ${ABORT} "The following sub-opts are EXOR applicable only:"
		  printERR $LINENO $BASH_SOURCE ${ABORT} "  CLIENT|SERVER|BOTH"
 		  gotoHell ${ABORT}
              fi

              #2. validate ambiguity of CMD
              if((_unambigCMD>1));then
		  ABORT=1;
		  printERR $LINENO $BASH_SOURCE ${ABORT} "The following sub-opts are EXOR applicable only:"
		  printERR $LINENO $BASH_SOURCE ${ABORT} "  REBOOT|RESET|SUSPEND|POWEROFF|INIT"
 		  gotoHell ${ABORT}
              fi


              #3. CLIENT is senseless with SUSPEND|RESET|POWEROFF
              if [ "${_CSB}" == CLIENT ];then
		  case ${KEY} in
		      SUSPEND|RESET|POWEROFF)
			  ABORT=1;
			  printERR $LINENO $BASH_SOURCE ${ABORT} "CLIENT cannot be combined with:SUSPEND|RESET|POWEROFF"
 			  gotoHell ${ABORT}
			  ;;
		  esac
              fi
          fi

          #4. Least required parameters
          if((_unambig!=1&&_idgiven!=1));then
	      ABORT=1;
	      printERR $LINENO $BASH_SOURCE ${ABORT} "Missing address parameter."
 	      gotoHell ${ABORT}
          fi


          #OK, anything seems to be fine now. So no additional syntactic checks required on 
          #server site.
          #The semantics, particularly results of locally filesystem or label expansion are still
          #to be checked of course.
	  ;;

      ACTION)
	  if [ -n "${R_TEXT}" ];then
	      echo "${R_TEXT}"
	  fi
	  if [ -z "${CTRL_EXECLOCAL}" ];then
	      assembleExeccall
	  else
              #
              #Doing local semantical correctness evaluation now.
              #
              if [ -n "$CTRL_MODE_ARGS" ];then
		  A=`echo ${CTRL_MODE_ARGS}|sed 's/,/ /g'`
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "WMW($A)"

                  #guarantee unambiguity of EXOR: (label|l)  (fname|f)  (pname|p)
		  local _unambig=0;
		  for i in $A;do
		      KEY=`echo ${i}|awk -F':' '{print $1}'|tr '[:lower:]' '[:upper:]'`
		      ARG=`echo ${i}|awk -F':' '{print $2}'`

		      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "KEY=${KEY}";
		      printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "ARG=${ARG}";
                      #handle keywords
                      if [ -n "${ARG}" \
			  -o -z "${ARG}" -a "${KEY}" == "CLIENT" \
			  -o -z "${ARG}" -a "${KEY}" == "SERVER" \
			  -o -z "${ARG}" -a "${KEY}" == "BOTH" \
			  -o -z "${ARG}" -a "${KEY}" == "S3" \
			  -o -z "${ARG}" -a "${KEY}" == "S4" \
			  -o -z "${ARG}" -a "${KEY}" == "S5" \
			  -o -z "${ARG}" -a "${KEY}" == "SUSPEND" \
			  -o -z "${ARG}" -a "${KEY}" == "RESET" \
			  -o -z "${ARG}" -a "${KEY}" == "STACK" \
			  -o -z "${ARG}" -a "${KEY}" == "FORCE" \
			  -o -z "${ARG}" -a "${KEY}" == "SELF" \
			  -o -z "${ARG}" -a "${KEY}" == "ALL" \
			  -o -z "${ARG}" -a "${KEY}" == "NOCACHE" \
			  -o -z "${ARG}" -a "${KEY}" == "NOPOLL" \
			  ];then
			  case $KEY in

                     ##################################################
                     # Common control enforcement scope and behaviour #
                     ##################################################
			      FORCE)
				  local _force=1;
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:FORCE"
				  ;;

			      STACK)
				  local _stack=1;
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:STACK (DEFAULT)"
				  ;;

			      SELF)
				  local _self=1;
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:SELF"
				  ;;


                     ##################
                     # Common methods #  
                     ##################
			      REBOOT)
				  local _reboot=1;
				  _behaviour=REBOOT;
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:REBOOT"
				  ;;
			      RESET)
				  _behaviour=RESET;
				  local _reset=1;
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:RESET"
				  ;;
			      PAUSE|S3)
				  _behaviour=PAUSE;
				  local _pause=1;
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:PAUSE-S3"
				  ;;
			      SUSPEND|S4)
				  _behaviour=SUSPEND;
				  local _suspend=1;
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:SUSPEND-S4"
				  ;;
			      POWEROFF|S5)
				  _behaviour=POWEROFF;
				  local _powoff=1;
				  local _powoffdelay="${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:POWEROFF-S5 DELAY=${_powoffdelay}"
				  ;;

			      INIT)
				  _behaviour=INIT;
				  local _init=1;
				  local _initstate="${ARG}";
				  [ -n "${_initstate}" ]&&_behaviour="${_behaviour}:${_initstate}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MODE:${_behaviour}"
				  ;;


                     #####################
                     # <machine-address> #
                     #####################
			      NOCACHE)
				  local _cache=0;
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "NOCACHE"
				  ;;
			      NOPOLL)
				  local _poll=0;
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "NOPOLL"
				  ;;



			      BASEPATH|BASE|B)
                                  local _base="${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:BASE=${_base}"
                                  for i in ${_base//\%/ };do
                                      if [ ! -d "${i}" ];then
					  ABORT=1;
					  printERR $LINENO $BASH_SOURCE ${ABORT} "Missing given base-path";
					  printERR $LINENO $BASH_SOURCE ${ABORT} "  i  = ${i}";
					  printERR $LINENO $BASH_SOURCE ${ABORT} "  PWD= ${PWD}";
					  printERR $LINENO $BASH_SOURCE ${ABORT} "Check your actual PWD when providing a relative base-path";
 					  gotoHell ${ABORT};
                                      fi
				  done
				  ;;

			      TCP|T)
				  local _tcp="${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "TCP=${_tcp}"
				  ;;

			      MAC|M)
				  local _mac="${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "MAC=${_mac}"
				  ;;

			      UUID|U)
				  local _uuid="${ARG}";
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:UUID=${_uuid}"
				  ;;

			      LABEL|L)
                                  local _label="${ARG}";
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:LABEL=${_label}"
				  ;;
			      FILENAME|FNAME|F)
                                  local _fname="${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:FILENAME=${_fname}"
				  ;;
			      ID|I|PATHNAME|PNAME|P)
                                  #can be checked now, no additional combination check required 
                                  #due to previous CHECKPARAM.
                                  if [ ! -f "${ARG}" ];then
				      ABORT=1;
				      printERR $LINENO $BASH_SOURCE ${ABORT} "Missing given pathname"
				      printERR $LINENO $BASH_SOURCE ${ABORT} "  _pname=${ARG}"
 				      gotoHell ${ABORT}
                                  fi
                                  local _pname="${_pname:+$_pname|}${ARG}";
				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:PATHNAME=${_pname}"
				  ;;


                     #####################
			      ALL)
				  local _all=1;
 				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "RANGE:all within scope"
				  ;;


			      CLIENT)
				  local _CSB=CLIENT;
  				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:CLIENT"
				  ;;
			      SERVER)
				  local _CSB=SERVER;
  				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:SERVER"
				  ;;
			      BOTH)
				  local _CSB=BOTH;
  				  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "SCOPE:BOTH=CLIENT+SERVER"
				  ;;


			      *)
				  ABORT=1;
				  printERR $LINENO $BASH_SOURCE ${ABORT} "Unexpected sub-opts for VMW:${KEY}"
 				  gotoHell ${ABORT}
				  ;;
			  esac
		      fi
		  done


                  #So basic isolated parameters seem to be OK, lets put them together.
		  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "CombineParamaters"

                  if [ -z "${_all}" ];then
                      if [ -z "${_pname}" ];then
                          #no pathname is given, so it has to be assembled.
			  local _pname=;
 			  local _VHOST="${MYCALLPATH}/ctys-vhost $_dbg1 -o IDS -p ${DBPATHLST} "


                          #
                          #1. Try CACHE
                          #   will perform AND search for all given parameters, take first
                          #   so uniqueness could be almost in any case enforced
                          #
			  if [ -n "${base}" ];then
			      local _i9=;
			      for _i9 in ${base//%/ };do
				  _pname=`${VHOST} ${_i9} ${_uuid} ${_label} ${_tcp} ${_mac} ${_fname}`
				  if [ -n "${_pname}" ];then
				      break;
				  fi
			      done
			  else
			      _pname=`${VHOST} ${_uuid} ${_label} ${_tcp} ${_mac} ${_fname}`
			  fi


                          #
                          #2. Use filesystem
                          #   This does an OR match and takes first.
                          #
			  if [ -z "${_pname}" ];then
			      printWNG $LINENO $BASH_SOURCE ${ABORT} "No CACHE hit by \"ctys-vhost\" searching filesystem"


			      if [ -n "${_uuid}" ];then
                                  #UUID to be "grepped" from vmx-files
				  _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,UUID,PID,SITE|\
                                       awk -F';' -v u="${_uuid}" '$3~u{print $1 ";" $2 ";" $4 ";" $5}'`
			      else
				  if [ -n "${_label}" ];then
                                      #displayName to be "grepped" from vmx-files
				      _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,PID,SITE|\
                                          awk -F';' -v l="${_label}" '$1~l{print $1 ";" $2 ";" $3 ";" $4}'`
				  else


				      if [ -n "${_tcp}" ];then
                                          #displayName to be "grepped" from vmx-files
 					  local _cx1=`${MYCALLPATH}/ctys-vhost $_dbg1 -o MAC -p ${DBPATHLST} ${_tcp}`
					  if [ -n "$_cx1" ];then
					      _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,MAC,PID,SITE|\
                                                      awk -F';' -v l="${_cx1}" '$3~l{print $1 ";" $2 ";" $4 ";" $5 ";" $3}'`
					  fi
					  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "_pname=${_pname}"
				      else
	 				  if [ -n "${_mac}" ];then
                                              #displayName to be "grepped" from vmx-files
					      _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,PID,SITE|\
                                                      awk -F';' -v l="${_mac}" '$1~l{print $1 ";" $2 ";" $3 ";" $4}'`
					      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "_pname=${_pname}"
					  else


					      if [ -n "${_fname}" ];then
                                                  #has to be a relative vmx-file name, the absolute path has to be found
   						  _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,PID,SITE|\
                                                         awk -F';' -v f="${_fname}" '$1~f{print $1 ";" $2 ";" $3 ";" $4}'`
					      fi
					  fi
				      fi
				  fi
			      fi
			  fi
                      else
                          #For multiple items the seperator has to be '|', than anything will work fine
                          #without looping required, but don't now what the maximum size is, should not 
                          #be reached for practical reasons.
			  _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,PID,SITE|\
                                      awk -F';' -v f="${_pname}" '$1~f{print $1 ";" $2 ";" $3 ";" $4}'`
		      fi
                  else
                      #So it is all
		      _pname=`listMySessions ${_CSB},FULLPATH,TERSE,LABEL,ID,PID,SITE`
		  fi

                  #
                  #Well, now we have complete list (probably a valid EMPTY-LIST) of sessions to be cancelled.
                  #with format:
                  #
                  #  <label>:<id=filepathname>:<pid>:<CLIENT|SERVER>
                  #
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "----------------------"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "- Cancel sessions:"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _force     = ${_force}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "----------------------"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _reboot    = ${_reboot}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _reset     = ${_reset}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _suspend   = ${_suspend}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _init      = ${_init} - ${_initstate}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _powoff    = ${_powoff} - ${_powoffdelay}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "----------------------"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "-  _behaviour = ${_behaviour}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "----------------------"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "  PATHNAME    = ${_pname}"
		  printVerboseDebug ${DBG_LVL_UID} $LINENO $BASH_SOURCE "----------------------"


                  ###########################
                   #    So, ... let's go!    #
                  ###########################

		  local _target="${MYHOST};${_pname%;*;*}";

                  if [ "${_CSB}" == CLIENT ];then
                      #Kill clients, guess the caller knows what he is doing, particularly
                      #has assured a stateless server by specific configuration of VMware, and
                      #is sure not to target a VMplayer!!!
                      #
                      #So, let's start the game!
                      #
  		      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "MODE=CANCEL(CLIENT)==KILL'em"
                      for _i in ${_pname};do
                          [ "${_i##*;}" != CLIENT ]&&continue;
			  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "kill:${_i}"
                          local _pid=${_i%;*}
                          _pid=${_pid##*;}
                          echo -n "Session:\"${_i%%;*}\":PID=$_pid"
                          kill $_pid
                          echo
                      done
		  else
		      case $_behaviour in
			  INIT)
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=INIT"
			      if [ -z "$_force" ];then
				  stackerCancelPropagate STACK "INIT:${_ARG}" "${_self:-$_target}";
			      fi
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "delay:${DEFAULT_KILL_DELAY_POWEROFF}"
			      sleep ${DEFAULT_KILL_DELAY_POWEROFF}
			      if [ -n "${_self}" ];then
  				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "SELF"
				  init ${_ARG}
			      fi
			      gotoHell 0
			      ;;

			  REBOOT)
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=REBOOT"
			      if [ -z "$_force" ];then
				  stackerCancelPropagate STACK "INIT:0" "${_self:-$_target}";
			      fi
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "delay:${DEFAULT_KILL_DELAY_POWEROFF}"
			      sleep ${DEFAULT_KILL_DELAY_POWEROFF}
			      if [ -n "${_self}" ];then
  				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "SELF"
				  reboot
			      fi
			      gotoHell 0
			      ;;

			  RESET)
                              #RESET
                              #reset servers controlled with proprietary tool 
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=RESET"

			      if [ -z "$_force" ];then
                                  #the "maybe" alternate would be to freeze the contained, and restart+reset
                                  #them when the container is available again, but what about interrupted/disrupted
                                  #session-timeouts, so prefer to keep things simple, a solution is NOT available
                                  #anyhow.
				  stackerCancelPropagate STACK "INIT:0" "${_self:-$_target}";
				  sleep ${DEFAULT_KILL_DELAY_POWEROFF}
			      fi

  			      for _i in ${_pname};do
				  [ "${_i##*;}" == CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "reset:${_i}"
				  local _id=${_i%;*;*}
				  _id=${_id#*;}
				  echo -n "RESET-SERVER Session:\"${_i%%;*}\":ID=$_id "
				  vmMgrVMW RESET $_id
				  echo
			      done
			      if [ -n "${_self}" ];then
  				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "SELF"
				  reboot
			      fi
 			      gotoHell 0
			      ;;

			  PAUSE|S3)
			      printWNG $LINENO $BASH_SOURCE ${ABORT} "PAUSE|S3 is not supported by VMW, partially mapped to S4"
                              #suspend servers controlled with proprietary tool first
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=PAUSE-S3"
			      if [ -z "$_force" ];then
				  stackerCancelPropagate STACK "PAUSE" "${_self:-$_target}";
				  sleep ${DEFAULT_KILL_DELAY_POWEROFF}
			      fi

			      for _i in ${_pname};do
				  [ "${_i##*;}" == CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "MAPPED TO suspend:${_i}"
				  local _id=${_i%;*;*}
				  _id=${_id#*;}
				  echo -n "MAPPED TO SUSPEND-SERVER Session:\"${_i%%;*}\":ID=$_id "
				  vmMgrVMW SUSPEND $_id
				  echo
			      done

                              #kill remaining clients 
			      for _i in ${_pname};do
				  [ "${_i##*;}" != CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "kill:${_i}"
				  local _pid=${_i%;*}
				  _pid=${_pid##*;}
				  echo -n "CANCEL-CLIENT Session:\"${_i%%;*}\":PID=$_pid"
				  kill $_pid
				  echo
			      done
			      if [ -n "${_self}" ];then
				  printWNG $LINENO $BASH_SOURCE ${ABORT} "PAUSE-S3 not yet supported, mapped to S5"
				  halt -p
			      fi
			      ;;

			  SUSPEND|S4)
                              #suspend servers controlled with proprietary tool first
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=SUSPEND-S4"
			      if [ -z "$_force" ];then
				  stackerCancelPropagate STACK "SUSPEND" "${_self:-$_target}";
				  sleep ${DEFAULT_KILL_DELAY_POWEROFF}
			      fi

			      for _i in ${_pname};do
				  [ "${_i##*;}" == CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "suspend:${_i}"
				  local _id=${_i%;*;*}
				  _id=${_id#*;}
				  echo -n "SUSPEND-SERVER Session:\"${_i%%;*}\":ID=$_id "
				  vmMgrVMW SUSPEND $_id
				  echo
			      done

                              #kill remaining clients 
			      for _i in ${_pname};do
				  [ "${_i##*;}" != CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "kill:${_i}"
				  local _pid=${_i%;*}
				  _pid=${_pid##*;}
				  echo -n "CANCEL-CLIENT Session:\"${_i%%;*}\":PID=$_pid"
				  kill $_pid
				  echo
			      done
			      if [ -n "${_self}" ];then
				  printWNG $LINENO $BASH_SOURCE ${ABORT} "SUSPEND-S4 not yet supported, mapped to S5"
				  halt -p
			      fi
 			      gotoHell 0
			      ;;

			  POWEROFF|S5)
                              #poweroff servers controlled with proprietary tool first
  			      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "ACTION-MODE=POWEROFF"

			      if [ -z "$_force" ];then
				  stackerCancelPropagate STACK "INIT:0" "${_self:-$_target}";
 				  sleep ${_powoffdelay:-DEFAULT_KILL_DELAY_POWEROFF}
			      fi

			      for _i in ${_pname};do
				  [ "${_i##*;}" == CLIENT ]&&continue;
				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "stop:${_i}"
				  local _id=${_i%;*;*}
				  _id=${_id#*;}
				  local _pid=${_i%;*}
				  _pid=${_pid##*;}
				  echo -n "POWEROFF-SERVER Session:\"${_i%%;*}\":ID=$_id DELAY=$_powoffdelay PID=$_pid"
				  vmMgrVMW POWEROFF $_id $_powoffdelay $_pid
				  echo
			      done

			      if [ "${_CSB}" != SERVER ];then 
                                      #kill remaining clients 
				  for _i in ${_pname};do
				      [ "${_i##*;}" != CLIENT ]&&continue;
				      printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "kill:${_i}"
				      local _pid=${_i%;*}
				      _pid=${_pid##*;}
				      echo -n "CANCEL-CLIENT Session:\"${_i%%;*}\":PID=$_pid"
				      kill $_pid
				      echo
				  done
			      fi
			      if [ -n "${_self}" ];then
  				  printVerboseDebug ${DBG_LVL_MAINT} $LINENO $BASH_SOURCE "SELF"
				  halt -p
			      fi
 			      gotoHell 0
			      ;;

			  *)

			      ABORT=1;
			      printERR $LINENO $BASH_SOURCE ${ABORT} "Reached unexpected execution tracepoint"
			      printERR $LINENO $BASH_SOURCE ${ABORT} "'seems to be, that a suboption of cancel is missing????"
			      printERR $LINENO $BASH_SOURCE ${ABORT} "This might be an internal error???"
			      gotoHell ${ABORT}
			      ;;
		      esac
                  fi
		  gotoHell 0
	      fi
	  fi
	  ;;
  esac
}


